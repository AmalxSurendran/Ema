// Autogenerated from Pigeon (v4.2.3), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
#if os(iOS)
import Flutter
#elseif os(macOS)
import FlutterMacOS
#else
#error("Unsupported platform.")
#endif


/// Generated class from Pigeon.

///Generated class from Pigeon that represents data sent in messages.
struct PlatformPose {
  /// A map of all the landmarks in the detected pose.
  var landmarks: [Int32?: PlatformPoseLandmark?]

  static func fromMap(_ map: [String: Any?]) -> PlatformPose? {
    let landmarks = map["landmarks"] as! [Int32?: PlatformPoseLandmark?]

    return PlatformPose(
      landmarks: landmarks
    )
  }
  func toMap() -> [String: Any?] {
    return [
      "landmarks": landmarks
    ]
  }
}

///Generated class from Pigeon that represents data sent in messages.
struct PlatformPoseLandmark {
  /// The landmark type.
  var type: Int32
  /// Gives x coordinate of landmark in image frame.
  var x: Double
  /// Gives y coordinate of landmark in image frame.
  var y: Double
  /// Gives z coordinate of landmark in image space.
  var z: Double
  /// Gives the likelihood of this landmark being in the image frame.
  var likelihood: Double

  static func fromMap(_ map: [String: Any?]) -> PlatformPoseLandmark? {
    let type = map["type"] as! Int32
    let x = map["x"] as! Double
    let y = map["y"] as! Double
    let z = map["z"] as! Double
    let likelihood = map["likelihood"] as! Double

    return PlatformPoseLandmark(
      type: type,
      x: x,
      y: y,
      z: z,
      likelihood: likelihood
    )
  }
  func toMap() -> [String: Any?] {
    return [
      "type": type,
      "x": x,
      "y": y,
      "z": z,
      "likelihood": likelihood
    ]
  }
}

///Generated class from Pigeon that represents data sent in messages.
struct PlatformInputImage {
  /// The bytes of the image.
  var bytes: [UInt8]
  var inputImageData: InputImageData

  static func fromMap(_ map: [String: Any?]) -> PlatformInputImage? {
    let bytes = map["bytes"] as! [UInt8]
    let inputImageData = InputImageData.fromMap(map["inputImageData"] as! [String: Any?])!

    return PlatformInputImage(
      bytes: bytes,
      inputImageData: inputImageData
    )
  }
  func toMap() -> [String: Any?] {
    return [
      "bytes": bytes,
      "inputImageData": inputImageData.toMap()
    ]
  }
}

///Generated class from Pigeon that represents data sent in messages.
struct InputImageData {
  /// Size of image.
  var height: Int32
  var width: Int32
  var imageRotation: Int32
  /// Format of the input image.
  var inputImageFormat: Int32
  /// The plane attributes to create the image buffer on iOS.
  ///
  /// Not used on Android.
  var planeData: [InputImagePlaneMetadata?]

  static func fromMap(_ map: [String: Any?]) -> InputImageData? {
    let height = map["height"] as! Int32
    let width = map["width"] as! Int32
    let imageRotation = map["imageRotation"] as! Int32
    let inputImageFormat = map["inputImageFormat"] as! Int32
    let planeData = map["planeData"] as! [InputImagePlaneMetadata?]

    return InputImageData(
      height: height,
      width: width,
      imageRotation: imageRotation,
      inputImageFormat: inputImageFormat,
      planeData: planeData
    )
  }
  func toMap() -> [String: Any?] {
    return [
      "height": height,
      "width": width,
      "imageRotation": imageRotation,
      "inputImageFormat": inputImageFormat,
      "planeData": planeData
    ]
  }
}

///Generated class from Pigeon that represents data sent in messages.
struct InputImagePlaneMetadata {
  /// The row stride for this color plane, in bytes.
  var bytesPerRow: Int32
  /// Height of the pixel buffer on iOS.
  var height: Int32? = nil
  /// Width of the pixel buffer on iOS.
  var width: Int32? = nil

  static func fromMap(_ map: [String: Any?]) -> InputImagePlaneMetadata? {
    let bytesPerRow = map["bytesPerRow"] as! Int32
    let height = map["height"] as? Int32 
    let width = map["width"] as? Int32 

    return InputImagePlaneMetadata(
      bytesPerRow: bytesPerRow,
      height: height,
      width: width
    )
  }
  func toMap() -> [String: Any?] {
    return [
      "bytesPerRow": bytesPerRow,
      "height": height,
      "width": width
    ]
  }
}

private class PlatformPoseDetectorCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return InputImageData.fromMap(self.readValue() as! [String: Any])      
      case 129:
        return InputImagePlaneMetadata.fromMap(self.readValue() as! [String: Any])      
      case 130:
        return PlatformInputImage.fromMap(self.readValue() as! [String: Any])      
      case 131:
        return PlatformPose.fromMap(self.readValue() as! [String: Any])      
      case 132:
        return PlatformPoseLandmark.fromMap(self.readValue() as! [String: Any])      
      default:
        return super.readValue(ofType: type)
      
    }
  }
}
private class PlatformPoseDetectorCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? InputImageData {
      super.writeByte(128)
      super.writeValue(value.toMap())
    } else if let value = value as? InputImagePlaneMetadata {
      super.writeByte(129)
      super.writeValue(value.toMap())
    } else if let value = value as? PlatformInputImage {
      super.writeByte(130)
      super.writeValue(value.toMap())
    } else if let value = value as? PlatformPose {
      super.writeByte(131)
      super.writeValue(value.toMap())
    } else if let value = value as? PlatformPoseLandmark {
      super.writeByte(132)
      super.writeValue(value.toMap())
    } else {
      super.writeValue(value)
    }
  }
}

private class PlatformPoseDetectorCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return PlatformPoseDetectorCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return PlatformPoseDetectorCodecWriter(data: data)
  }
}

class PlatformPoseDetectorCodec: FlutterStandardMessageCodec {
  static let shared = PlatformPoseDetectorCodec(readerWriter: PlatformPoseDetectorCodecReaderWriter())
}

///Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol PlatformPoseDetector {
  func processImage(inputImage: PlatformInputImage, completion: @escaping (PlatformPose) -> Void)
  func closeDetector()
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class PlatformPoseDetectorSetup {
  /// The codec used by PlatformPoseDetector.
  static var codec: FlutterStandardMessageCodec { PlatformPoseDetectorCodec.shared }
  /// Sets up an instance of `PlatformPoseDetector` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: PlatformPoseDetector?) {
    let processImageChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.PlatformPoseDetector.processImage", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      processImageChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let inputImageArg = args[0] as! PlatformInputImage
        api.processImage(inputImage: inputImageArg) { result in
          reply(wrapResult(result))
        }
      }
    } else {
      processImageChannel.setMessageHandler(nil)
    }
    let closeDetectorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.PlatformPoseDetector.closeDetector", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      closeDetectorChannel.setMessageHandler { _, reply in
        api.closeDetector()
        reply(nil)
      }
    } else {
      closeDetectorChannel.setMessageHandler(nil)
    }
  }
}

private func wrapResult(_ result: Any?) -> [String: Any?] {
  return ["result": result]
}

private func wrapError(_ error: FlutterError) -> [String: Any?] {
  return [
    "error": [
      "code": error.code,
      "message": error.message,
      "details": error.details
    ]
  ]
}
