// Autogenerated from Pigeon (v4.2.3), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import
import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

class PlatformPose {
  PlatformPose({
    required this.landmarks,
  });

  /// A map of all the landmarks in the detected pose.
  Map<int?, PlatformPoseLandmark?> landmarks;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['landmarks'] = landmarks;
    return pigeonMap;
  }

  static PlatformPose decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return PlatformPose(
      landmarks: (pigeonMap['landmarks'] as Map<Object?, Object?>?)!
          .cast<int?, PlatformPoseLandmark?>(),
    );
  }

  PlatformPose copyWith({
    Map<int?, PlatformPoseLandmark?>? landmarks,
  }) =>
      PlatformPose(landmarks: Map.from(landmarks ?? this.landmarks));
}

class PlatformPoseLandmark {
  PlatformPoseLandmark({
    required this.type,
    required this.x,
    required this.y,
    required this.z,
    required this.likelihood,
  });

  /// The landmark type.
  int type;

  /// Gives x coordinate of landmark in image frame.
  double x;

  /// Gives y coordinate of landmark in image frame.
  double y;

  /// Gives z coordinate of landmark in image space.
  double z;

  /// Gives the likelihood of this landmark being in the image frame.
  double likelihood;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['type'] = type;
    pigeonMap['x'] = x;
    pigeonMap['y'] = y;
    pigeonMap['z'] = z;
    pigeonMap['likelihood'] = likelihood;
    return pigeonMap;
  }

  static PlatformPoseLandmark decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return PlatformPoseLandmark(
      type: pigeonMap['type']! as int,
      x: pigeonMap['x']! as double,
      y: pigeonMap['y']! as double,
      z: pigeonMap['z']! as double,
      likelihood: pigeonMap['likelihood']! as double,
    );
  }

  List<String> toStringList() => [
        x.toStringAsFixed(4),
        y.toStringAsFixed(4),
        z.toStringAsFixed(1),
        likelihood.toStringAsFixed(4)
      ];
}

class PlatformInputImage {
  PlatformInputImage({
    required this.planes,
    required this.inputImageData,
  });

  /// The bytes of the image.
  List<Uint8List?> planes;
  InputImageData inputImageData;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['planes'] = planes;
    pigeonMap['inputImageData'] = inputImageData.encode();
    return pigeonMap;
  }

  static PlatformInputImage decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return PlatformInputImage(
      planes: (pigeonMap['planes'] as List<Object?>?)!.cast<Uint8List?>(),
      inputImageData: InputImageData.decode(pigeonMap['inputImageData']!),
    );
  }
}

class InputImageData {
  InputImageData({
    required this.height,
    required this.width,
    required this.imageRotation,
    required this.inputImageFormat,
    required this.planeData,
  });

  /// Size of image.
  int height;
  int width;
  int imageRotation;

  /// Format of the input image.
  int inputImageFormat;

  /// The plane attributes to create the image buffer on iOS.
  ///
  /// Not used on Android.
  List<InputImagePlaneMetadata?> planeData;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['height'] = height;
    pigeonMap['width'] = width;
    pigeonMap['imageRotation'] = imageRotation;
    pigeonMap['inputImageFormat'] = inputImageFormat;
    pigeonMap['planeData'] = planeData;
    return pigeonMap;
  }

  static InputImageData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return InputImageData(
      height: pigeonMap['height']! as int,
      width: pigeonMap['width']! as int,
      imageRotation: pigeonMap['imageRotation']! as int,
      inputImageFormat: pigeonMap['inputImageFormat']! as int,
      planeData: (pigeonMap['planeData'] as List<Object?>?)!
          .cast<InputImagePlaneMetadata?>(),
    );
  }
}

class InputImagePlaneMetadata {
  InputImagePlaneMetadata({
    required this.bytesPerRow,
    this.bytesPerPixel,
    this.height,
    this.width,
  });

  /// The row stride for this color plane, in bytes.
  int bytesPerRow;
  int? bytesPerPixel;

  /// Height of the pixel buffer on iOS.
  int? height;

  /// Width of the pixel buffer on iOS.
  int? width;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['bytesPerRow'] = bytesPerRow;
    pigeonMap['bytesPerPixel'] = bytesPerPixel;
    pigeonMap['height'] = height;
    pigeonMap['width'] = width;
    return pigeonMap;
  }

  static InputImagePlaneMetadata decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return InputImagePlaneMetadata(
      bytesPerRow: pigeonMap['bytesPerRow']! as int,
      bytesPerPixel: pigeonMap['bytesPerPixel'] as int?,
      height: pigeonMap['height'] as int?,
      width: pigeonMap['width'] as int?,
    );
  }
}

class _PlatformPoseDetectorCodec extends StandardMessageCodec {
  const _PlatformPoseDetectorCodec();

  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is InputImageData) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is InputImagePlaneMetadata) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is PlatformInputImage) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is PlatformPose) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is PlatformPoseLandmark) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:
        return InputImageData.decode(readValue(buffer)!);

      case 129:
        return InputImagePlaneMetadata.decode(readValue(buffer)!);

      case 130:
        return PlatformInputImage.decode(readValue(buffer)!);

      case 131:
        return PlatformPose.decode(readValue(buffer)!);

      case 132:
        return PlatformPoseLandmark.decode(readValue(buffer)!);

      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class PlatformPoseDetector {
  /// Constructor for [PlatformPoseDetector].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  PlatformPoseDetector({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _PlatformPoseDetectorCodec();

  Future<PlatformPose> processImage(PlatformInputImage arg_inputImage) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PlatformPoseDetector.processImage', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_inputImage]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as PlatformPose?)!;
    }
  }

  Future<void> closeDetector() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PlatformPoseDetector.closeDetector', codec,
        binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error =
          (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}
